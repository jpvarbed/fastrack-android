\documentclass{acm_proc_article-sp}
\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage{dblfloatfix}
\usepackage{fancyvrb}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{example}{Verbatim}{fontsize=\small}
\begin{document}

\title{Applying Desktop Race Detector Techniques to Mobile Systems}
\numberofauthors{2}
\author{
\alignauthor Dan Jonik\\
\affaddr{University of Michigan, Ann Arbor}\\
\email{djonik@umich.edu}
\and
\alignauthor Jason Varbedian\\
\affaddr{University of Michigan, Ann Arbor}\\
\email{jpvarbed@umich.edu}
}
\date{25 April 2012}
\maketitle

\begin{abstract}
Mobile systems have recently become prevalent with more smart phones being sold than any other computing device. Development for these systems has increased as fast as the sales with applications and systems requiring more powerful hardware. Smart phones are being released with multicore architectures and come with the same multithreaded programming difficulty as desktop systems face. Debugging and developing applications for these multicore mobile platforms is a difficult task and few if any tools exist specifically for concurrency detection.
 
This paper presents an implementation and port of the FastTrack race detector for the Android mobile system. Android lacks any true instrumentation library and most Java instrumentation is done at runtime instead of compile which don't work on Android. The tool is able to detect errors in simple applications we wrote ourselves while running on an Android emulator. 
\end{abstract}

\section{Introduction}
Multiple cores and multithreaded programming has become the standard on desktop systems. Chips have had to increase the number of cores to increase computing power. To take advantage of these cores multiprogramming is often used. Programming for multiple cores is often non-trivial even for so-called 'embarrassingly parallel' calculations. The challenge is greater for large applications and services like browsers and servers. Several tools have been developed for desktop systems to help with debugging these programs.
 
Smart phones are becoming multicore and apps are running  with multiple threads. Many data race detectors and multithreaded programming tools have been developed for desktop systems, but few exist for mobile systems. The introduction of multicore processors to mobile space introduces non-deterministic bugs. These bugs inhibit development as the current technique for solving non-deterministic concurrency errors is the use of exhaustive, expensive, and time-consuming tests. These tools will run an app for a significant period of time with many different environment variables and output diagnostic logs. There are exponentially-many interleavings to explore and it can be difficult to pinpoint when and where an error occurred; additionally, it is just as difficult to reproduce a bug once it has been found. There is an obvious need for tools to air developers in finding data races before they manifest into multithreaded bugs.

There have been many race detectors, record and replay systems, and other tools to monitor and debug concurrent programs for desktop systems. In our research and our time working in industry with commercial Android products, we have found no such tools for mobile systems. It is possible there are proprietary tools that Apple and Microsoft use for their mobile systems, bu there isn't yet a publicly-available one for Android.
 
Our hypothesis is that data race techniques implemented on desktop systems can be applied to mobile systems. Our project ports a low-overhead, fast, and thorough dynamic race detector called FastTrack that runs on the Java Virtual Machine to Android's Dalvik Virtual Machine. The detector FastTrack \cite{Flanagan2009} implements an algorithm that, used with the dynamic analysis framework RoadRunner, can monitor memory accesses and synchronization operations in concurrent Java programs. FastTrack checks that programs follow a \emph{happens-before} relationship\cite{Flanagan2010} with lightweight vector clocks that, in most cases, use constant space and time operations. RoadRunner provides an API for communicating an event stream to back-end analysis tools; FastTrack monitors this event stream to monitor an application's behavior. The tool makes debugging multithreaded applications much faster and easier to fix by providing detailed information about each detected data race.
 
In this paper we make two contributions:
\begin{enumerate}
\item Describe issues with porting data race detection systems to Android
\item A partial port of FastTrack and RoadRunner to Android
\end{enumerate}

The rest of the paper is organized as follows. The following section reviews tools used for multithreaded program debugging and development and explains our choice of which tool is the most appropriate to port to Android. Section 3 describes the  RoadRunner instrumentation framework. Section 4 explains the algorithm used by FastTrack to build and monitor a \emph{happens-before} graph. Section 5 presents the modifications we made to the FastTrack tool to run it on Android, followed by an evaluation of our work in Section 6. 

\section{Survey of Existing Tools}
There are many techniques for detecting data races and providing record and replay capabilities for desktop multithreaded applications. We surveyed different tools and systems to determine which would be the most appropriate for use in a mobile computing environment. Mobile systems, compared to desktops and laptops, have less memory and fewer cores since energy is a limiting resource for system performance; therefore, we were most interested in debugging tools that had relatively small memory footprints and performance overheads. False positives, when a benign data race is erroneously reported as an error, greatly limit a tool's usefulness and usability, so we favored tools that guaranteed to report only legitimate errors. Several debugging tools require developers to make modifications to their application's source code before the tool can be used. This is not only a burden to the programmer, but also could possibly introduce additional bugs that were not previously present. Our ideal tool requires no source code modifications to preserve both correctness and usability. Our analysis of five different desktop multithreaded debugging tools is presented below.

\begin{description}
\item[DoublePlay] \cite{Veeraraghavan2012} is a deterministic system that provides guaranteed record and replay with minimal overhead at the cost of using more cores.  It does so by running the original multithreaded program on half the of cores and taking "checkpoints", while at the same time running multiple time-slices of a single-processor execution on the other half of the cores. The key insight is that by running different time-slices of a program each on their own individual core, multithreaded code can be executed and then replayed deterministically without a severe performance hit. In case of a mismatch between the single-processor execution and the multiprocessor execution, both executions are rolled back to the last checkpoint and restarted. DoublePlay is very effective because it offers full replay capabilities to multithreaded software, does not report false positives, and introduces little slow down. However, since DoublePlay is based on the assumption that the system on which it is running has unused cores (an assumption that most definitely does not apply to mobile systems), we decided that it was not the best option for porting to Android. 

\item[Eraser] \cite{Savage1997} is a system used to detect data races in programs that use locks for synchronization by using the \emph{lock-set} algorithm. Eraser keeps track of which locks are held at each access to a shared object; if there is ever an access in which the set of locks held is empty, a data race is reported. Unfortunately, there are several circumstance in which false positives may be reported, such as user-implemented synchronization techniques. When these situations arise, developers are forced to add statements to their code telling Eraser to ignore certain objects and accesses. Eraser implements a straightforward data race detection algorithm, but ultimately fails on two of our predefined criteria, requiring source code modification and reporting of false positives.


\item[Kendo]  \cite{Olszewski2009} is a tool that guarantees weak determinism for multithreaded applications. It modifies the POSIX thread library to ensure a deterministic order of all lock acquisitions for a given set of inputs based on the current progress of each thread. Unfortunately, Kendo requires programmers to insert library calls around intentionally racy reads to flag them as benign so that Kendo ignores them. Perhaps an even bigger limitation is that Android applications run on the native Java Thread library; therefore, porting Kendo to Android would require a complete reimplementation as well as redefining a native Java library, which is discourage and limits the system's portability.


\item[CHESS] \cite{Musuvathi2008} is a system for systematically testing concurrent systems for bugs that appear only in certain thread interleavings. It does so by taking control of the thread scheduler and exhaustively enumerating all possible thread interleavings. To reduce the number of program execution paths that must be explored, threads are preempted only at certain key instructions (instead of at every instruction) that are most likely to be central to any bugs that appear. CHESS offers no false positives and near-complete code coverage, but requires the creation of wrappers to allow the tool to run on top of different development platforms  Additionally, it is a resource-hungry  application which would experience performance problems on mobile devices.


\item[FastTrack] \cite{Flanagan2009} is able to monitor any concurrent Java program and report only true data races with full \emph{happens-before} coverage. By instrumenting compiled Java class files at load time, it uses a shadow memory system to watch all synchronization and memory  operations. It is able to identify the type of data race that has occured, which threads were involved, and which variable was the cause.  FastTrack uses a shortened version of vector clocks, known as \emph{epochs}, to monitor the \emph{happens-before} relationship. \emph{Epochs} reduce the memory overhead of the system, as well as speed up the comparison operations used to check for data races. FastTrack is the ideal algorithm choice for an Android race detector since it requires no source modifications, it has a small memory and performance overhead, and it reports only true data races.
\end{description}

\section{RoadRunner}
RoadRunner is a dynamic analysis framework for monitoring concurrent Java programs. It provides an interface for compiled Java bytecode instrumentation without requiring any changes to the underlying virtual machine. RoadRunner outputs updated class files that have additional function calls to the RoadRunner framework wrapped around each synchronization operation and memory access. When an instrumented class file is executed, it will be making calls to RoadRunner, which then broadcasts the events to any programs, such as FastTrack, that have subscribed to the event stream. These programs can then monitor and handle the events in whatever way they desire.


\subsection{RoadRunner API}
RoadRunner provides an abstract class, Tool, that allows different types of programs to be built on top of RoadRunner. Inside of this class, developers must specify how to handle different types of events that come from RoadRunner by overwriting virtual event handler functions; although a wide variety of events are broadcast, tools only need to write handlers for the events that they care about. FastTrack is an extension of the Tool class that monitors all memory operations and synchronization operations. The fastTrack event handlers use the events to construct a \emph{happens-before} graph which is then used to monitor for data races.


\subsection{Instrumentation}
RoadRunner uses the ASM \cite{Bruneton02} library to instrument Java classes at load time from a compiled Java .class file. A shadow variable is created for each static member of the class, as well as getter and putter functions to access the variable. \emph{ShadowThread} objects and function calls are inserted to the class to keep track of variable accesses between threads. An example instrumented class is below in Figure \ref{instrumentation}.
  \begin{figure}[h]
    \centering
    %\begin{minipage} [h] {7.5cm}
      \includegraphics[scale=.5]{instrumentatin_new}
      \caption{An example of an instrumented class. A ShadowVar \emph{x} is created along with its get and put functions. The current thread is stored in the ShadowThread and used in the access operations.\label{instrumentation}}
    %\end{minipage}
  \end{figure}


\section{FastTrack}
FastTrack is an extension of RoadRunner that uses a modified \emph{happens-before} relationship to monitor concurrent programs. It monitors an event stream and reports if there are any race conditions. A \emph{happens-before} relation is represented by vector clocks \cite{citeulike} which use considerable memory and require costly comparison operations. Given an application with  \emph{n} threads, each vector clock requires \emph{O(n)} storage space and each vector clock comparison operation requires \emph{O(n)} time. Previous tools have chosen between the precision (no false positives) and large overhead of full vector clocks and the imprecision of lightweight \emph{happens-before} techniques which produces many false alarms. FastTrack leverages a new lightweight vector clock design, \emph{epochs}, that, in most cases, uses constant time and space to provide accurate race detection and low overhead suitable for mobile environments.

\subsection{Happens-Before Relationship}
The \emph{happens-before} relationship is an important relation in distributed and parallel systems. As defined by Leslie Lamport \cite{Lamport1978}, it is a `relation between the result of two events, such that if one event should happen before another event, the result must reflect that even if those events are in reality executed out of order'. If the happens-before relation is respected during execution, then a program has no data races. 

\subsection{FastTrack Algorithm}
The key to the FastTrack algorithm's low overhead is the observation that most operations don't require a full vector clock to check for \emph{happens-before} violations on an object, just the information about the last time the object was accessed. The algorithm stores an \emph{epoch} for the last access in most cases, which is a tuple of the vector clock time (c)  and thread (t) denoted \emph{c@t}. The insight is that writes are ordered until there is a date race, so the algorithm just needs to check if a new read or write proceeds the last recorded \emph{epoch}. Let\emph{ V1} and \emph{V2} be the vector clocks of threads 1 and 2, respectively.
% \begin{figure}[h]
%    \centering
%    \begin{minipage} [b] {8cm}
%      \includegraphics[scale=1]{termin}
%    \end{minipage}
%    \begin{minipage} [b] {7cm}
%      \includegraphics[scale=1]{lessthan}
%	\caption{Terminology\label{termin}}
%    \end{minipage}
%  \end{figure}
Figure \ref{trace} shows a sample trace and how the epochs \emph{Wx} and \emph{Rx} are updated between two threads with vector clocks \emph{C0} and \emph{C1}.
 \begin{figure}[h]
    \centering
    %\begin{minipage} [b] {7.5cm}
      \includegraphics[scale=.55]{full_trace_new}
      \caption{Sample Trace\label{trace}}
    %\end{minipage}
  \end{figure} 


Figures \ref{read} and \ref{write} shows how FastTrack handles reads and writes for different types of accesses, and the observed percentage of each operation type from several benchmarks. Since read operations aren't always ordered (one could finish after with a earlier clock time) and a program would still be correct, it is sometimes necessary to keep a full vector clock to make sure the very last read isn't changed by a write. The takeaway here is that less than 1\% of reads and writes require operations on full vector clocks; the rest require only a comparison involving an epoch which runs in \emph{O(1)} time. 

 \begin{figure}[h]
    \centering
    \includegraphics[scale=.4]{fast_read_new}
	\caption{Read Accesses\label{read}}
 \end{figure}
\begin{figure}[h]
	\centering
    \includegraphics[scale=.4]{fast_write_new}
\caption{Write Accesses\label{write}}
  \end{figure}


\section{Implementation}
This section describes the changes we made to FastTrack and RoadRunner to work with Android applications on Android 2.1. Unfortunately, Android does not provide any libraries for bytecode instrumentation, which is absolutely necessary to run FastTrack. Because of this, we essentially split the original desktop implementation of FastTrack so that it runs in two separate phases:

\begin{enumerate}
\item Instrument .class files in Java Virtual Machine and store updated bytecode files
\item Run Android application on Dalvik Virtual Machine with updated bytecode files with FastTrack included in application as external library
\end{enumerate}

The details are provided in the following sections.


\subsection{Instrumentation}
The java.lang.Instrument library is used by RoadRunner to instrument the target application's .class files \cite{Flanagan2009}. When running RoadRunner on a desktop machine, a user specifies which tools they want to use, as well as the target application. For example, the line 
\begin{code}
	rrrun -tool=FT test.Test
\end{code}
tells FastTrack (FT) to monitor the execution of class \emph{Test} in the package \emph{test}. As soon as RoadRunner and FastTrack have both been initialized, the .class file for the class \emph{Test} is instrumented using the native Java Instrument library. During the instrumentation, a \emph{metadata} file is also generated that records the static members fields and member functions for all of the target application's classes. This file is used later to look up class members as they are accessed while the application executes. As soon as the instrumentation has completed and the \emph{metadata} file has been created, \emph{Test} is executed. 

As mentioned before, Android provides no libraries that support binary instrumentation. Because of this, we were forced to instrument the target Android application code in the Java Virtual Machine. Since the instrumented files would eventually be running inside an Android application, RoadRunner was modified to store the instrumented files into a temporary directory where they could be loaded back into the Android application that they belong to. This is phase 1 of our FastTrack implementation as described earlier.

\subsection{Tool Startup Modifications}
A minor problem arises from the way the original FastTrack tool was invoked; the sample \emph{rrrun} command shows that the target class to run is passed in at runtime as a parameter. This model of execution does not translate well to Android applications. When users want to run an application (whether on a physical Android device or in an emulator), they simply click on the icon for that application and it gets loaded into the Dalvik Virtual Machine. 

To stay consistent with our goal of creating a tool with seamless usability, we needed to restructure the boot sequence of FastTrack. Our new implementation of FastTrack automatically initializes itself the first time that it receives an event from the underlying RoadRunner framework. Since the application code has been instrumented, it contains calls to the FastTrack tool. If the tool receives a call before it has loaded its tool properties file and the application's \emph{metadata} file, it will do so, and upon finishing, continue to handle the function call from the application. 

\subsection{Exposed Interface}
Although our implementation of FastTrack is able to initialize itself as described in the previous section, it does require a small modification to the application's source code. We expose our entire FastTrack interface as a single function call that must be made by the Android application's top level class. It is defined as follows:

\begin{code}
void initFTSession(InputStream propertyFileHandle,
	           InputStream metadataFileHandle);
\end{code}

Since the FastTrack library is included in the application as a .jar file that is compiled in the Java Virtual Machine, it does not have the ability to open resources from the \emph{assets} folder of the target Android application, which is where the tool property and \emph{metadata} files are stored. The user is required to simply created \emph{InputStream} objects to each of these two files and pass them to FastTrack. Although a completely transparent implementation would have been preferred, this single function call is much simpler than other race detector tools that require extensive updates to an application's source code.

\subsection{Integration with Android Application}
In order to run an Android application with our implementation of FastTrack, there are two phases as mentioned before. The first phase handles the bytecode instrumentation. Since this is done in the Java Virtual Machine (due to the dependency on java.lang.Instrument), the application's source code must be compiled with the Java compiler \emph{javac}; once this has been done, FastTrack can be invoked with the same command that the original implementation used. However, our FastTrack tool will write out the newly instrumented .class files to a temporary directory that also contains the compiled FastTrack source. 

Once the instrumentation step is done, this directory is sanitized and compressed to a .jar file.  Sanitation refers to the removal of classes that are not needed in our FastTrack implementation in order to minimize its size in memory. The .jar file can then be added to the Android application with a simple \emph{Import} operation in the Eclipse IDE. When the application is run, the compiled source code contained in the .jar file will be executed, which includes calls to the FastTrack library. This is considered phase two of our FastTrack implementation; at this point, if any data races are detected, error messages are printed to Eclipse's Logcat console, which can be dumped to a text file for preservation.


\section{Evaluation}
This project started out as a proof-of-concept that FastTrack could be ported to run on Android's Dalvik Virtual Machine. After we had completed our implementation, we were able to run a set of multithreaded test cases on an Android emulator. Since we had written the test cases manually, it was known which tests contained legitimate data races. Our FastTrack implementation was able to correctly identify such data races and printed the appropriate error messages. 

\subsection{Resource Usage}
To supplement our evaluation of FastTrack's correctness, we also observed the amount of computing resources that were required by the race detector. There was a risk of too much memory being consumed by the application's source code since instrumentation adds a considerable amount of shadow variables and member functions to each file. However, we noticed that instrumented files were only, on average, 30\% larger than their original version. Additionally, we package up the instrumented source as a .jar file, which involves a compression algorithm. We noticed that file sizes decreased to up to 40\% of their original size when being added to the .jar file. This effectively cancels out any memory overhead due to instrumentation.

A major concern with many race detectors is the slowdown incurred by the race detection algorithm running in the background. FastTrack employs \emph{epochs} to help reduce this overhead, which makes a significant improvement compared to tools such as Eraser that can cause applications to run 100 times slower \cite{Savage1997}. We noticed slowdowns around 10 times the original applications execution time, which is consistent to the performance overhead of the original FastTrack system running on a desktop system \cite{Flanagan2010}.

\subsection{Usability}
A significant limit of our system is the inability to instrument code that uses Android libraries. Since the instrumentation happens in the Java Virtual Machine, any code that cannot be compiled with \emph{javac} cannot be instrumented. Therefore, our implemented of FastTrack will only be able to detect data races in the files of an application that contain exclusively native Java code.

Although we have proved the concept that FastTrack can be applied to the Android mobile operating system, it is not yet a complete data race detector. Before a fully robust race detector can be written for Android, a instrumentation class must be added to Android that allows the instrumentation of .dex files (compiled Java code format used on the Dalvik VM).


\section{Conclusion}
Our analysis of a range of data race detectors and record and replay systems has led us to the conclusion that FastTrack is the best option for mobile systems. It runs with relatively low overhead, and can verify a \emph{happens-before} relationship for the majority of synchronization operations and memory accesses with operations that can in \emph{O(1)} complexity. Our implementation of the FastTrack tool allows for efficient and correct data race detection in Android applications that run native Java code on the Dalvik Virtual Machine.

\bibliographystyle{acm}
\bibliography{monitor}
\end{document}